---
title: "Cell trajectory of mesoderm development LOH with Totem"
author: "Elo lab - <https://elolab.utu.fi>"
date: "`r format(Sys.Date(), '%d/%m/%Y')`"
bibliography: references.bib
output: 
   html_document:
      toc: true 
      toc_float: true
      theme: united
      code_folding: hide
---

<br>

<br>

---

<br>

<br>

## Totem workflow

<br>

In order to run `Totem`, one needs only log normalized single-cell gene expression data. `Totem` is a novel trajectory inference method for tree shaped cell trajectory topologies such as linear, bifurcation, multifurcation or tree-shaped. It relies mainly on two steps: (1) clustering; and (2) MSTs. In between, there are a serial of intermediate steps to handle the data and tune some parameters based on visualizations and user knowledge. `Totem` introduces the concept of "cell connectivity" which consists in the average of how many cells a given cluster is connected to through a set of clustering results which helps the user to identify and support the potential starting and ending points of the trajectory. In this tutorial We will go through the main steps listed below.   

<br>

   1. Prepare data
   
   2. Feature selection
   
   3. Dimensionality reduction 
   
   4. Clustering

   5. Cell connectivity

   6. Select clusterings

   7. Smooth MSTs

   8. Define a root

   9. Pseudotime 

<br>

<br>

---

<br>

<br>

## Setup 

<br>

Load R packages and set seed. 

```{r seed}
# Set seed
set.seed(1204)
```

```{r packages, message=FALSE, warning=FALSE}
# Load packages
library("dplyr")
library("Totem")
library("ggplot2")
library("dynwrap")
library("dyndimred")
library("SingleCellExperiment")
```

<br>

<br>

---

<br>

<br>

## Download & import data set

<br>

The applicability of Totem for cell trajectory inference (TI) is demonstrated with a data set that met the following criteria:

   1. publicly available (single-cell RNA-seq data);
   
   2. with known ground-truth cell trajectory;
   
   3. with tree-shaped cell trajectory topology;
   
   4. real world data (non-simulate). 
   
A set of data sets that meet all these criteria were made publicly available by the [dynverse benchmarking](https://github.com/dynverse/dynbenchmark) team [@saelens2019comparison] on _Zenodo_: [https://zenodo.org/record/1443566#.Y-83vGFByrx](https://zenodo.org/record/1443566#.Y-83vGFByrx). Among the ones that met the criteria, we selected the data set: `mesoderm-development_loh` (link to [download](https://zenodo.org/record/1443566/files/real/gold/mesoderm-development_loh.rds?download=1)).
   
This data set can be downloaded and imported into R environment by running the next lines of code. 

```{r download & import datasets}
# Download data sets
url2down <- "https://zenodo.org/record/1443566/files/real/gold/mesoderm-development_loh.rds?download=1"
download.file(url = url2down, destfile = "../data/mesoderm-development_loh.rds")

# Import data sets
dyn <- readRDS(file = "../data/mesoderm-development_loh.rds")
```

The R object downloaded (file extension `.rds`), `mesoderm-development_loh.rds`,  was saved in the folder `data` and imported and saved into R with the object name `dyn`. 

The class of `dyn` is essentially a list of objects related with `dynwrap`: `r class(dyn)`.

Among the classes printed above, we can see expression and grouping `dynwrap` objects. `dynwrap` is also a R package that we will use to access the data from the `dyn` object. 

<br>

<br>

---

<br>

<br>

## (1) Prepare data

<br>

`Totem` requires only log normalized data as input which can be obtained by using common single-cell processing software tools such as `Seurat` [@hao2021integrated] or `scanpy`  [@wolf2018scanpy]. 

><p><font size=2>How do I get log normalized data from counts?</p></font>

<details><summary>*Answer*</summary><p> 

Assuming you have counts from single-cell gene expression data, you have at least the following three alternatives to perform log normalization: 

   1. R without external tools: applying basic R functions
   
      + `apply()` R function can be used to apply the formula `log1p(x/sum(x)*10000)` (natural log, with 1 pseudocount, of the relative gene expression scaled by 1e4) to every column, i.e., cell, in the `counts` matrix
      
```{r log-norm, eval=FALSE, include=TRUE}
## Log normalization
counts <- get_expression(dataset = dyn, expression_source = "counts") # get 'counts'
counts <- t(counts) # transpose (rows x cols): cells x genes --> genes x cells 
log_norm <- apply(counts, 2, function(x) log1p(x/sum(x)*10000)) # log1p normalization w/ 10K scaling factor
```
   
   2. `Seurat`: a R package available from [https://satijalab.org/seurat/](https://satijalab.org/seurat/)
   
      + use the `Seurat` function `NormalizeData(..., normalization.method="LogNormalize", scale.factor = 10000)` (see [docs](https://satijalab.org/seurat/reference/normalizedata))
   
   3. `scanpy`: a python package available from [https://scanpy.readthedocs.io/en/stable/](https://scanpy.readthedocs.io/en/stable/)
   
      + use the `scanpy` function `scanpy.pp.normalize_total(..., target_sum=10000)` (see [docs](https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.normalize_total.html#scanpy.pp.normalize_total))

</p></details>

`Totem` conveniently uses the `SingleCellExperiment` (SCE) R package and class to store all the information that generates in its workflow. A SCE object with the counts and log normalized data can be created as presented next. Cell metadata can be added, in case the user has any. Please have a look into the section [Chapter 4 The SingleCellExperiment class](https://bioconductor.org/books/3.17/OSCA.intro/the-singlecellexperiment-class.html) of the [OSCA](https://bioconductor.org/books/3.17/OSCA.intro/) book to learn more about the `SingleCellExperiment` class and functionality.  

```{r sce}
## Create a SCE object for Totem

# Retrieve counts and log normalized and groupings data from 'dyn' object 
#or use your own
counts <- get_expression(dataset = dyn, expression_source = "counts") # get 'counts'
log.counts <- get_expression(dataset = dyn, expression_source = "expression") # get 'counts'
groups <- get_grouping(dataset = dyn)
cell_ids <- names(groups)

# Transpose (rows x cols): cells x genes --> genes x cells 
# dynwrap assumes: cells x genes
# SCE object assumes: genes x cells 
counts <- t(counts)
log.counts <- t(log.counts)

# Create SCE object
sce <- SingleCellExperiment(assays = list("counts" = counts, "logcounts" = log.counts), 
                            colData = data.frame("Group" = groups, row.names = cell_ids))
```

Before starting the workflow, we exclude any potential non expressed gene from our SCE object. 

```{r prepare data}
## Prepare data for Totem: remove non-expressed genes
sce <- PrepareTotem(object = sce)
```

The `sce` object created contains the assays `r paste(assayNames(sce), collapse=", ")`, the cell metadata `r colnames(colData(sce))` with `r nrow(sce)` genes and `r ncol(sce)` cells. 

<br>

<br>

---

<br>

<br>

## (2) Feature selection

<br>

The next step consists in feature selection. This is not mandatory but highly recommended due to the following reasons: 

   1. the differential expression of some genes may reflect technical or bias effects rather than biological signal which might be masked upon selection of top _n_ highly variable genes
   
   2. removes uninformative genes such as lowly abundant or showing an invariant gene expression across different cells
   
   3. increases the computational speed of downstream steps due to the reduced dimensionality
   
This step can be performed with any software tool of your choice, such as `Seurat` or `scanpy`. The only required information is a list of HVG that needs to be provided to `Totem`. Below we provide a solution for the selection of 2K HVG using the software R package `scran`.  

```{r hvg}
## Selection of HVG w/ scran R package
var.genes <- scran::modelGeneVar(sce)
hvg <- scran::getTopHVGs(var.genes, n = 2000)
```

The object `hvg` is a character vector with the names of top 2K HVG (`r paste(head(hvg), collapse=", ")`, ...).

<br>

<br>

---

<br>

<br>

## (3) Dimensionality reduction

<br>

The next step in the workflow consists in dimensionality reduction for clustering purposes downstream of this stage. 

The user can use any low-dimensional representation method of its choice that represents the data, such as PCA (Principal Component Analysis), UMAP (Uniform Manifold Approximation and Projection for Dimension Reduction), _t_-SNE ( _t_-distributed Stochastic Neighbourhood Embedding) or LMDS (landmark Multi-Dimensional Scaling). 

Next We will use LMDS, but the `Totem` vignette provides some tips if you want to use other method (see [vignette](https://htmlpreview.github.io/?https://github.com/elolab/Totem-benchmarking/blob/main/Totem.html#tips)).

You can skip this step if you have your own low-dimensional representation already (see the next paragraph). In this step, We perform LMDS for the HVG determined in the previous step (by giving `dim.red.features = hvg`) and selecting the first 5-dimensional latent representations. In case you do not want to use HVG, just change `dim.red.features = hvg` to `dim.red.features = NULL`.

```{r dimred}
## Dimensionality reduction
sce <- RunDimRed(object = sce,
                 dim.red.method = "lmds",
                 dim.red.features = hvg,
                 dim.reduction.par.list = list(ndim=5))
```

In case you have already your own low-dimensional representation, just add it to the SCE object

```{r add dimred}
## Add low-dimensional representation to SCE object
own_dim_red <- reducedDim(sce) # substitute this line by importing your own dimensional result (define class as matrix (rows x cols: cells x latent dimensions))
reducedDim(sce, type = "lmds") <- own_dim_red # type can be 'pca', 'umap' whatever you want - this is the name given to the dimensional result
```

We need a 2-dimensional representation rather than LMDS for visualization purposes. Adequate methods are UMAP, `t`-SNE or MDS. Any of these can be directly provided by the user in case they generated previously any or generated _de novo_ as follows using the `dyndimred` R package functions (UMAP: `dimred_umap()`; _t_-SNE: `dimred_tsne()`; MDS: `dimred_mds()`). Below We perform the MDS.   

```{r 2D dimred}
## Select 2D dimensional reduction for visualization
dim_red <- dimred_mds(t(log.counts), ndim=2)
```

The result can be visualized below. 

```{r viz mds}
## Visualize 'Group' in UMAP projection
cbind(dim_red, "Cell_type"=sce$Group) %>% 
  as.data.frame(.) %>% 
  mutate_at(c("comp_1", "comp_2"), as.numeric) %>% 
  ggplot(data = ., mapping = aes(x = comp_1, y = comp_2, color = Cell_type)) + 
  geom_point() + 
  theme_bw()
```

<br>

<br>

---

<br>

<br>

## (4) Clustering 

<br>

Clustering is one of the main steps in the `Totem` workflow and the one that takes more time and computational resources. `Totem` is use the 5-dimensional latent representations of LMDS are used to cluster the data set with the k-medoids (CLARA) algorithm using an expected number of clusters varying between 3-20 (`k.range = 3:20`), removing clusters with <5 cells (`min.cluster.size = 5`) and running the clustering algorithm 10K times (`N.clusterings = 10000`). These are the default parameters. After filtering out clustering results due to `min.cluster.size`, the total number of clustering results will be lower than `N.clusterings`. 

```{r cluster}
## Clustering scRNA-seq data w/ CLARA (k-medoids)
set.seed(123)
sce <- RunClustering(object = sce, k.range = 3:20,
                     min.cluster.size = 5, N.clusterings = 10000)
```

<br>

<br>

---

<br>

<br>

## (5) Cell connectivity

<br>



```{r cell connect viz}
## Visualization of cell connectivity
VizCellConnectivity(object = sce, viz.dim.red = dim_red)
```

<br>

<br>

---

<br>

<br>

## (6) Select clusterings

<br>

The clustering can be selected based on 5 methods described in detail in the `Totem` vignette (see [vignette](https://htmlpreview.github.io/?https://github.com/elolab/Totem-benchmarking/blob/main/Totem.html#clustering-selection)). You can also see the function documentation by typing the following in the R console: `?SelectClusterings`.

Here, We selected the top 5 models with the method 3 which was demonstrated to perform well compared with other methods [@smolander2022totem].

```{r select clusters}
## Select best clusters for MST calculation
sce <- SelectClusterings(sce, selection.method = 3,
                         selection.N.models = 5,
                         selection.stratified = FALSE,
                         prior.clustering = NULL)
```

Below it appears highlighted the 5 selected clusterings and their respective MSTs. 

```{r viz selected clusters}
## Visualize selected clusters
select.clusters <- ReturnTrajNames(sce)
VizMST(object = sce, clustering.names = select.clusters, viz.dim.red = dim_red)
```

<br>

<br>

---

<br>

<br>

## (7) Smooth MSTs

<br>

Smooth MSTs using the `slingshot` method [@street2018slingshot]. 

```{r smooth msts}
## Smoothing MSTs selected w/ Slingshot
sce <- RunSmoothing(sce)
```

Visualize smoothed MSTs below.

```{r viz smoothed msts}
## Visualize smoothed MSTs
smooth.msts.names <- ReturnTrajNames(sce)
VizSmoothedTraj(object = sce,
                traj.names = smooth.msts.names,
                viz.dim.red = dim_red,plot.pseudotime = FALSE)
```

<br>

<br>

---

<br>

<br>

## (8) Define a root 

<br>

The highest values of cell connectivity were for cluster 3. Therefore, let's pick the cluster 3 as the root. 

```{r root}
## Define the root of the cell trajectory
root.cluster <- 3
sce <- ChangeTrajRoot(object = sce, traj.name = smooth.msts.names[1], root.cluster = root.cluster)
```

<br>

<br>

---

<br>

<br>

## (9) Pseudotime

<br>

Visualize pseudotime.

```{r viz pseudotime}
VizSmoothedTraj(object = sce,
                traj.names = smooth.msts.names[1],
                viz.dim.red = dim_red, plot.pseudotime = FALSE)
VizSmoothedTraj(object = sce,
                traj.names = smooth.msts.names[1],
                viz.dim.red = dim_red, plot.pseudotime = TRUE)
```

<br>

<br>

---

<br>

<br>

## Compare against ground-truth

<br>

```{r compare ground-truth}
## Compare Totem pseudotime against ground-truth
cowplot::plot_grid(
  (VizSmoothedTraj(object = sce,
                traj.names = smooth.msts.names[1],
                viz.dim.red = dim_red, plot.pseudotime = TRUE) + 
     ggtitle("Totem")),
  (dynplot::plot_dimred(dyn, color_cells = "pseudotime", dimred = dim_red) + 
     ggtitle("Ground-truth")), 
   ncol=2
   )
```

<br>

<br>

---

<br>

<br>

#### R packages used and respective versions

<br>

```{r versions, message=FALSE, warning=FALSE, paged.print=FALSE}
## R packages and versions used in these analyses
sessionInfo()
```

<br>

<br>

---

<br>

<br>

## References
